package icircles.abstractDescription;
/**
 * Tests for @see AbstractBasicRegion.
 *
 * @author Aidan Delaney <aidan@phoric.eu>
 * Copyright (c) 2012
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are
 * those of the authors and should not be interpreted as representing official
 * policies, either expressed or implied, of the iCircles Project.
 */

import java.util.Set;
import java.util.TreeSet;

import org.junit.*;
import org.junit.runner.RunWith;
import static org.junit.Assert.*;
import static org.hamcrest.CoreMatchers.*;
import org.jcheck.annotations.Configuration;
import org.jcheck.annotations.Generator;

/**
 * Implements tests for {@link AbstractBasicRegion}.
 *
 * FIXME: We don't do enough testing for passing null values into methods.
 */
@RunWith(org.jcheck.runners.JCheckRunner.class)
public class TestAbstractBasicRegion {

    /**
     * Tests the get method of @link AbstractBasicRegion
     *
     * Creates two @link AbstractBasicRegion from the same @link AbstractCurve set
     * then compares to ensure they're equal.  Then remove one AbstractCurve from
     * one AbstractBasicRegion and recompare for inequality.
     *
     * @param acs The arbitrary length (<= 20) array of arbitrary @link AbstractCurve objects generated by JCheck
     */
    @Test
    @Configuration(tests=100, size=20) //limit the AbstractCurve[] to be lower than 20 elements 
    @Generator(klass=AbstractCurve.class, generator=CustomAbstractCurveGen.class)
    public void testGet(AbstractCurve[] acs) {
        if(0 == acs.length) {
            assertTrue(true);
            return;
        }

        TreeSet<AbstractCurve> in_set = new TreeSet<AbstractCurve>();

        for(AbstractCurve ac : acs) {
            in_set.add(ac);
        }
        AbstractBasicRegion abr1 = AbstractBasicRegion.get(in_set);

        for(AbstractCurve ac : acs) {
            in_set.add(ac);
        }

        AbstractBasicRegion abr2 = AbstractBasicRegion.get(in_set);

        assertEquals(abr1, abr2);
        // get one of the AbstractCurves on the outside
        AbstractCurve first = in_set.first();
        abr2 = abr2.moveOutside(first);

        assertFalse("abr1: " + abr1.journalString() + "\nabr2: " + abr2.journalString() , abr1.equals(abr2));
    }

    /**
     * Test that {@link AbstractBasicRegion #moveOutside} and {@link AbstractBasicRegion #moved_in} are duals of each other.
     *
     */
    @Test
    @Configuration(tests=100, size=20) //limit the AbstractCurve[] to be lower than 20 elements 
    @Generator(klass=AbstractCurve.class, generator=CustomAbstractCurveGen.class)
    public void testMoveOutsideMoved_In(AbstractCurve[] acs) {
        if(0 == acs.length) {
            assertTrue(true);
            return;
        }

        TreeSet<AbstractCurve> in_set = new TreeSet<AbstractCurve>();

        for(AbstractCurve ac : acs) {
            in_set.add(ac);
        }

        AbstractBasicRegion abr1 = AbstractBasicRegion.get(in_set);

        AbstractCurve first = in_set.first();
        assertEquals(abr1, abr1.moveOutside(first).moved_in(first));
    }

    @Test
    @Configuration(tests=100, size=20) //limit the AbstractCurve[] to be lower than 20 elements 
    @Generator(klass=AbstractCurve.class, generator=CustomAbstractCurveGen.class)
    public void testCompareTo(AbstractCurve[] acs) {
        if(0 == acs.length) {
            assertTrue(true);
            return;
        }

        TreeSet<AbstractCurve> in_set = new TreeSet<AbstractCurve>();

        for(AbstractCurve ac : acs) {
            in_set.add(ac);
        }

        AbstractBasicRegion abr1 = AbstractBasicRegion.get(in_set);

        for(AbstractCurve ac : acs) {
            in_set.add(ac);
        }

        AbstractBasicRegion abr2 = AbstractBasicRegion.get(in_set);

        assertEquals(0, abr1.compareTo(abr2));

        AbstractCurve first = in_set.first();
        assertEquals(-1, abr1.moveOutside(first).compareTo(abr2));
        assertEquals(1, abr2.compareTo(abr1.moveOutside(first)));
    }


    @Test
    @Configuration(tests=100, size=20) //limit the AbstractCurve[] to be lower than 20 elements 
    @Generator(klass=AbstractCurve.class, generator=CustomAbstractCurveGen.class)
    public void testGetStraddledContour(AbstractCurve[] acs) {
        // need at least two controus for this test
        if(acs.length < 2) {
            assertTrue(true);
            return;
        }

        TreeSet<AbstractCurve> in_set = new TreeSet<AbstractCurve>();

        for(AbstractCurve ac : acs) {
            in_set.add(ac);
        }

        AbstractBasicRegion abr1 = AbstractBasicRegion.get(in_set);

        for(AbstractCurve ac : acs) {
            in_set.add(ac);
        }

        AbstractBasicRegion abr2 = AbstractBasicRegion.get(in_set);

        assertEquals(null, abr1.getStraddledContour(abr2));
        assertEquals(null, abr2.getStraddledContour(abr1));

        // remove a contour from abr2
        AbstractCurve ac = in_set.first();
        abr2 = abr2.moveOutside(ac);

        assertEquals(ac, abr1.getStraddledContour(abr2));
        assertEquals(ac, abr2.getStraddledContour(abr1));

        // remove another contour from abr2
        ac = in_set.last();
        abr2 = abr2.moveOutside(ac);
        assertEquals(null, abr1.getStraddledContour(abr2));
        assertEquals(null, abr2.getStraddledContour(abr1));
    }

    @Test
    @Configuration(tests=100, size=20) //limit the AbstractCurve[] to be lower than 20 elements 
    @Generator(klass=AbstractCurve.class, generator=CustomAbstractCurveGen.class)
    public void testIsLabelEquivalent(AbstractCurve[] acs) {
        // Again, need at least one curve
        if(0 == acs.length) {
            assertTrue(true);
            return;
        }

        TreeSet<AbstractCurve> in_set = new TreeSet<AbstractCurve>();

        for(AbstractCurve ac : acs) {
            in_set.add(ac);
        }

        AbstractBasicRegion abr1 = AbstractBasicRegion.get(in_set);

        for(AbstractCurve ac : acs) {
            in_set.add(ac);
        }

        AbstractBasicRegion abr2 = AbstractBasicRegion.get(in_set);

        assertTrue(abr1.isLabelEquivalent(abr2));

        AbstractCurve first = in_set.first();
        assertFalse(abr1.moveOutside(first).isLabelEquivalent(abr2));
        assertFalse(abr1.isLabelEquivalent(abr2.moveOutside(first)));
    }

    @Test
    public void testABREquivalence () {
        CurveLabel    a  = CurveLabel.get("a");
        AbstractCurve a1 = new AbstractCurve(a);
        AbstractCurve a2 = new AbstractCurve(a);

        Set<AbstractCurve> sa1 = new TreeSet<AbstractCurve>();
        sa1.add(a1);
        Set<AbstractCurve> sa2 = new TreeSet<AbstractCurve>();
        sa1.add(a2);

        AbstractBasicRegion abr1 = AbstractBasicRegion.get(sa1);
        AbstractBasicRegion abr2 = AbstractBasicRegion.get(sa2);


        // Reference equality
        assertTrue(abr1 != abr2);

        // Deep equality
        assertThat(abr1, is(not(abr2)));

    }
}
